## 一、背景
今天突然想要优化一段代码，我们线上有业务，我们将用户存储在1000个好短中，然后线上有50台机器，通过RPC调用的方式将1000个号段通过1000次RPC调用，这1000次RPC调用通过负载均衡的方式，每台机器大概会收到20次RPC调用，每一次的RPC调用都通过异步方式处理，然后每个号段的用户大概2万用户，这2万用户异步处理之后是单线程处理方式。我们今天要做的事情就是将每个号段的异步处理方式转换成并行处理方式提升处理速度。
## 二、并行优化
1、业务逻辑
每个用户
```java
package com.zbt.thread;

import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ThreadPoolExecutor;

/**
 * @author zoubaitao
 * date 2022/08/04
 */
@Slf4j
public class CheckService {

    private static final int INNER_BATCH_SIZE = 5;

    private void check() {
        try {
            Thread.sleep(20);
        } catch (Exception ex) {
            log.error("execute checkService error", ex);
        }
    }

    public void serialization(int batchSize) {
        for (int i = 0; i < batchSize; i++) {
            check();
        }
    }

    public void parallel(ThreadPoolExecutor threadPoolExecutor, int batchSize) {
        CountDownLatch countDownLatch = new CountDownLatch(batchSize);
        for(int i = 0 ; i < batchSize ;i++) {
            threadPoolExecutor.submit(() -> {
                try {
                    check();
                } catch (Exception ex) {
                    log.error("batch execute check method error", ex);
                } finally {
                    countDownLatch.countDown();
                }
            });
        }

        try {
            countDownLatch.await();
        } catch (Exception ex) {
            log.error("execute countDownLatch await method error", ex);
        }

    }

    public void parallelWithSplit(ThreadPoolExecutor threadPoolExecutor, int batchSize) {
        int total = batchSize % INNER_BATCH_SIZE == 0
                ? batchSize / INNER_BATCH_SIZE
                : (batchSize / INNER_BATCH_SIZE) + 1;
        CountDownLatch countDownLatch = new CountDownLatch(total);
        List<Callable<Void>> callables = new ArrayList<>(total);
        for (int i = 0; i < total; i++) {
            Callable<Void> callable = () -> {
                try {
                    for (int j = 0; j < INNER_BATCH_SIZE; j++) {
                        check();
                    }
                } catch (Exception ex) {
                    log.error("batch execute check method error", ex);
                } finally {
                    countDownLatch.countDown();
                }

                return null;
            };
            callables.add(callable);
        }
        try {
            threadPoolExecutor.invokeAll(callables);
        } catch (Exception ex) {
            log.error("batch async execute callables error", ex);
        }
        try {
            countDownLatch.await();
        } catch (Exception ex) {
            log.error("execute countDownLatch await method error", ex);
        }
    }
}
```
线程池
```java
package com.zbt.thread;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author zoubaitao
 * date 2022/08/04
 */
public class ThreadPoolManager {
    /**
     * 阻塞队列采用SynchronousQueue
     */
    private static final ThreadPoolExecutor synchronousExecutor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors() * 3,
            Runtime.getRuntime().availableProcessors() * 4,
            60,
            TimeUnit.SECONDS, new SynchronousQueue<>(),
            new ThreadPoolExecutor.CallerRunsPolicy());

    /**
     * 阻塞队列采用synchronous
     */
    private static final ThreadPoolExecutor outerArrayBlockingExecutor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors() * 3,
            Runtime.getRuntime().availableProcessors() * 4,
            60,
            TimeUnit.SECONDS, new ArrayBlockingQueue<>(5000),
            new ThreadPoolExecutor.CallerRunsPolicy());


    /**
     * 阻塞队列采用synchronous
     */
    private static final ThreadPoolExecutor innerArrayBlockingExecutor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors() * 3,
            Runtime.getRuntime().availableProcessors() * 4,
            60,
            TimeUnit.SECONDS, new ArrayBlockingQueue<>(5000),
            new ThreadPoolExecutor.CallerRunsPolicy());

    private ThreadPoolManager() {

    }

    public static ThreadPoolExecutor getSynchronousExecutor() {
        return synchronousExecutor;
    }

    public static ThreadPoolExecutor getOuterArrayBlockingExecutor() {
        return outerArrayBlockingExecutor;
    }

    public static ThreadPoolExecutor getInnerArrayBlockingExecutor() {
        return innerArrayBlockingExecutor;
    }

}
```

测试代码
```java
package thread;

import com.zbt.thread.CheckService;
import com.zbt.thread.ThreadPoolManager;
import junit.framework.TestCase;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CountDownLatch;

/**
 * @author zoubaitao
 * date 2022/08/04
 */
@Slf4j
public class ThreadBenchmarkTest extends TestCase {
    private static final int RPC_CALL_NUM = 20;
    private static final int BATCH_USER_NUM = 200;
    private static final int TOTAL_LOOP = 100;

    public void testSerialization() {
        long start = System.currentTimeMillis();
        CheckService checkService = new CheckService();
        CountDownLatch countDownLatch = new CountDownLatch(RPC_CALL_NUM);
        for (int i = 0; i < RPC_CALL_NUM; i++) {
            ThreadPoolManager.getOuterArrayBlockingExecutor().submit(() -> {
                try {
                    for (int j = 0; j < TOTAL_LOOP; j++) {
                        checkService.serialization(BATCH_USER_NUM);
                    }
                } catch (Exception ex) {
                    log.error("", ex);
                } finally {
                    countDownLatch.countDown();
                }
            });

        }
        try {
            countDownLatch.await();
        } catch (Exception ex) {
            log.error("execute CountDownLatch await error", ex);
        }
        log.info("并行+串行, 耗时::{}",(System.currentTimeMillis()-start));
    }

    public void testParallelWithSynchronous() {
        long start = System.currentTimeMillis();
        CheckService checkService = new CheckService();
        CountDownLatch countDownLatch = new CountDownLatch(RPC_CALL_NUM);
        for (int i = 0; i < RPC_CALL_NUM; i++) {
            ThreadPoolManager.getOuterArrayBlockingExecutor().submit(() -> {
                try {
                    for (int j = 0; j < TOTAL_LOOP; j++) {
                        checkService.parallel(ThreadPoolManager.getSynchronousExecutor(), BATCH_USER_NUM);
                    }
                } catch (Exception ex) {
                    log.error("", ex);
                } finally {
                    countDownLatch.countDown();
                }
            });

        }
        try {
            countDownLatch.await();
        } catch (Exception ex) {
            log.error("execute CountDownLatch await error", ex);
        }
        log.info("并行+并行+SynchronousQueue+不分割, 耗时::{}",(System.currentTimeMillis()-start));
    }

    public void testParallelWithArrayBlocking() {
        long start = System.currentTimeMillis();
        CheckService checkService = new CheckService();
        CountDownLatch countDownLatch = new CountDownLatch(RPC_CALL_NUM);
        for (int i = 0; i < RPC_CALL_NUM; i++) {
            ThreadPoolManager.getOuterArrayBlockingExecutor().submit(() -> {
                try {
                    for (int j = 0; j < TOTAL_LOOP; j++) {
                        checkService.parallel(ThreadPoolManager.getInnerArrayBlockingExecutor(), BATCH_USER_NUM);
                    }
                } catch (Exception ex) {
                    log.error("", ex);
                } finally {
                    countDownLatch.countDown();
                }
            });

        }
        try {
            countDownLatch.await();
        } catch (Exception ex) {
            log.error("execute CountDownLatch await error", ex);
        }

        log.info("并行+并行+ArrayBlockingQueue+不分割, 耗时::{}",(System.currentTimeMillis()-start));
    }

    public void testParallelWithSplitAndSynchronous() {
        long start = System.currentTimeMillis();
        CheckService checkService = new CheckService();
        CountDownLatch countDownLatch = new CountDownLatch(RPC_CALL_NUM);
        for (int i = 0; i < RPC_CALL_NUM; i++) {
            ThreadPoolManager.getOuterArrayBlockingExecutor().submit(() -> {
                try {
                    for (int j = 0; j < TOTAL_LOOP; j++) {
                        checkService.parallelWithSplit(ThreadPoolManager.getSynchronousExecutor(), BATCH_USER_NUM);
                    }
                } catch (Exception ex) {
                    log.error("", ex);
                } finally {
                    countDownLatch.countDown();
                }
            });

        }
        try {
            countDownLatch.await();
        } catch (Exception ex) {
            log.error("execute CountDownLatch await error", ex);
        }
        log.info("并行+并行+SynchronousQueue+分割, 耗时::{}",(System.currentTimeMillis()-start));
    }

    public void testParallelWithSplitAndArrayBlocking() {
        long start = System.currentTimeMillis();
        CheckService checkService = new CheckService();
        CountDownLatch countDownLatch = new CountDownLatch(RPC_CALL_NUM);
        for (int i = 0; i < RPC_CALL_NUM; i++) {
            ThreadPoolManager.getOuterArrayBlockingExecutor().submit(() -> {
                try {
                    for (int j = 0; j < TOTAL_LOOP; j++) {
                        checkService.parallelWithSplit(ThreadPoolManager.getInnerArrayBlockingExecutor(), BATCH_USER_NUM);
                    }
                } catch (Exception ex) {
                    log.error("", ex);
                } finally {
                    countDownLatch.countDown();
                }
            });

        }
        try {
            countDownLatch.await();
        } catch (Exception ex) {
            log.error("execute CountDownLatch await error", ex);
        }
        log.info("并行+并行+ArrayBlockingQueue+分割, 耗时::{}",(System.currentTimeMillis()-start));
    }
}
```
## 三、结论
|用户|单用户耗时(ms)|队列+拒绝策略|分割|总耗时(ms)|
|:---:|:---:|:---:|:---:|:----:|
|400,000|20|none|否|446482|
|400,000|20|Syncrhonous+CallerRunsPolicy|否|133699|
|400,000|20|ArrayBlockingQueue+CallerRunsPolicy|否|249356|
|400,000|20|Syncrhonous+CallerRunsPolicy|是|137906|
|400,000|20|ArrayBlockingQueue+CallerRunsPolicy|是|248918|


* 从上面的测试结果可以看到并行处理用户和串行处理用户耗时能够减少70%左右。
* 从队列模型可以看到对于SynchronousQueue和ArrayBlockingQueue相比，Synchronous的性能比ArrayBlockingQueue要好很多。
* 对于大的任务是否需要分割成小的任务其实也需要视情况而定，有时候会因为任务分割而导致分割任务占据一定的耗时。
* 因为我们的每一个任务都需要被处理而且不允许使丢弃任务，用CallerRunsPolicy正好能够符合我们的业务需求。
