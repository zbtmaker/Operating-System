# 线程池源码解读
线程池顾名思义就是存储线程的地方，因为每次任务来临的时候创建线程，然后处理业务，等业务处理完成之后，线程也随之销毁。如果不断的有业务需要处理，那么需要每次创建线程，处理业务，销毁线程，这个开销很大。因此采用线程池将已创建的线程保存在线程池中，每次有业务需要线程时，可以从线程池获取线程，然后处理业务，业务处理结束之后，将线程交还给线程池管理。

## 线程池相关参数
## 线程池

如果队列中有任务的时候，线程池时时如何运行的，如果线程池中的队列为空的时候，线程池又是如何运行的。

我们首先来看一下当我们提交一个线程时
```java
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
         /*
          * 1、如果线程池中已经有corePoolSize个线程在运行，则尝试创建一个新的线程
          * 运行次任务，并且次任务作为首要的任务。调用addWorker方法会以原子方式校验
          * runState和workerCount两个参数，以免此时不应该添加线程从而返回false。
          *
          * 2、如果一个任务能够成功进入到等待队列，我们仍然会使用双检查的方式来判断
          * 我们是否需要新增一个Worker，又或者在调用此方法的时候线程池已经停止了。
          *
          * 3、如果我们无法将task放入队列中，我们需要尝试创建一个线程来执行task.
          * 如果添加到队列失败，这个时候就是队列已经满了活着是线程池已经停止了，
          * 此时提交的任务会被拒绝。
          * 
          */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```