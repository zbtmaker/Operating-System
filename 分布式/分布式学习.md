# 分布式学习
Raft主要关注的三个方面，
* Leader选举
* log复制
* 安全问题
解决好上面三个问题，一个基本的分布式系统就可以做好了。
## 一、选举
### 问题和解答
其实在阅读[Raft网站](https://raft.github.io/)的时候有一些疑问，这里主要从选举、复制（目前只是知道这两个方面）。

首先列举选举相关问题：
* 选举一问：因为Raft集群服务器存在三种角色，Follower、Leader、Candidate。Follower和Leader是选举之后的状态，那么当一个Leader宕机之后。各个Server的角色是什么样的呢？比方说之前的Follower角色，现在会变成什么样的角色呢？
  
  选举一答：在Raft论文中，一个Server在一个Cluster中的最开始的角色时Follower角色，我们假定在一个选举完成的状态下，因为Leader会以一个固定的频率给集群中的Follower发送心跳检测，如果Follower在其设定的timeout超时时间之前还没有收到Leader的心跳检测，此时Follower就会进入Candidate角色；Candidate角色开始向集群中其他的Server发送选举请求（这里的其他Server是包括Leader角色的Server），如果在一个选举周期内，没有投出一个有效的Leader（这里一个周期内，如何算是投出一个有效的Leader，我们后面做出说明），此时Candidate角色的Server的角色保持不变，进入下一轮投票；如果Candidate角色的Server在投票期间获得了Cluster中大部分的Server的投票，那么Candidate角色就会转变为Leader角色；Follower角色又是如何发生变化的呢？Follower角色在收到一个比自己term更大的请求的时候，就会自然的从Leader角色转变为Follower角色。当然，上述的状态变化没有涉及到更多的细节，以及还存在一些疑问，我们把这些在学习过程中遇到的一些疑问，我们列举在下方，并成为一个问题继续探索。

* 选举二问：在上面我们提到一个选举周期，在一个选举周期呢？
  
  选举二答：Raft在论文中提到吧time分割成不同的term，每个term的时长是不一样的，在每一个term开始时都需要进行选举，选举完成之后开始响应Client的请求。如果自一个term中没有选举出合适的Leader（一个集群中超过一半的Server都投这个Server作为Leader），那么此时term就会结束，同时集群中的每一个Server的term在前一个term基础上自增。

  这里也提到，集群中的Server在通信时会传递自己的term，如果一个Server发现自己的term比其他Server的term要小，那么这个Server就需要升级自己的term。如果一个Server收到请求的term，这里在文中被称为stale term（过期term）， Server会拒绝请求。

  虽然我觉得这种方式不大靠谱，因为每个term都有选举，选举完成之后才能服务Client的请求，这个在现实的互联网世界，基本上时不可能的。那么实际的数据又是怎样的呢？，可以看一下 ETCD、Redis的设计方式。

* 选举三问：如果在一个term中，一个 Follower未收到一个Leader的心跳检测，那么之前为Follower角色的Server就会转变为Candidate角色。此时Server只是一个角色的转换吗？会开启一个新的term吗，因为Candidate此时会向集群中其他的Server发出选举请求。在文中提到一句一个Candidate或者Leader如果发现自己的term已经过时，此时Candidate、Leader就需要转变成Follower角色？
  
  选举三答：一个Follower因为在其timeout内没有收到Leader的心跳进检测，就会从Follower角色转换成Candidate，同时会向Cluster中其他的Server发送投票，此时应该也会带上自己的term。在选举二答中提到term的同步时通过服务器之间的通信会带上自己的term，同时其他Server在发现自己的term小于发起请求的Server的term就会升级自己的term，同时一个Leader或者一个Candidate发现自己的term小于其他Server的term时会从之前的角色转换成Follower角色。


* 选举四问：因为是一个分布式系统，没有一个集中的决策机制，正是通过这种机制，那么一个Follower又是如何决定要给一个Candidate投赞成票还是投反对票。

* 选举二问：当选举中是否会出现多个Leader（即分布式中著名的拜占庭将军问题），同时多个Leader是否最终能够由一个Leader来统领。Raft算法是如何解决词问题的。

* 选举三问：当一个Candidate成为了Leader之后，那么其他的Candidate是如何确认了自己的Follower身份的。
  
* 选举X问：我们提到一台Server在其 timeout时间内没有收到Leader发送过来的心跳检测就会自动转换成为一个Candidate角色，那么这个Server的timeout是如何合理决定的呢？

* 选举四问：选举中Candidate发出的请求和选举完成之后发出的心跳保活请求是否是同一个类型，那么Candidate和Follower角色的Server是如何做出区分的，同时又是如何回应的。

选举中Candidate发出的请求和选举完成之后发出的心跳保活请求是否是同一个类型，那么Candidate和Follower角色的Server是如何做出区分的，同时又是如何回应的。

* 在Raft的原文中提到了两种Rpc，一种是RequestVote主要是在当一个集群中的Follower无法感知到Leader时，此时Follower的角色就会转换成Candidate，此时就会使用RequestVote类型的Rpc与集群中其他Server进行通信。这个通信的目的是让其他 Follower知道自己已经是Candidate，投自己一票。还有一种是Entries Rpc，这种Rpc请求的方式就是Server将自己的log同步给Follower。
* 那么这个时候衍生出一个问题，当一个集群正常运行时，集群中的Follower是如何知道其他 Follower的地址的。我想应该是当一个Candidate在成为Follower的同时，应该会发送一个Rpc请求，将集群中存活的所有Server的IP和Host同步给集群中所有的Follower。那么这中Rpc使用的是RequestVote Rpc还是使用Entries Rpc呢？如果是让我来设计，我应该如何设计呢？我想我会创建一个新的Rpc来解决这个问题。
* 当一个Server成为leader后，就会向集群中的Follower发送心跳检测，一旦一个集群中的一个Follower在规定的时间内没有收到Leader发送的心跳检测，此时Follower就会成为一个Candidate角色，当这个Follower成为了Candidate的时候，Candidate又收到了Leader的心跳检测，那么此时Candidate时如何处理Leader的心跳检测，Leader是如何处理Candidate发送的选举消息。文中说明了Server处于Candidate角色是如果受到了其他Leader的AppendEntries RPC请求，那么Candidate就需要比较发送AppendEntries RPC的Leader的term，如果Candidate的term比Leader的term大，那么Candidate就会无视Leader的AppendEntries RPC请求，继续向集群中其他的Server发送RequestVote RPC请求，也就是继续进入选举状态。

* 根据上面的描述，如果一个集群中既有Leader角色的Server、Candidate角色的Server、Follower角色的Server，那么Leader在收到Candidate的RequestVote RPC时是不是也要比较Candidate的term和Leader自己的比较？

* Follower角色的Server如果同时收到Leader的AppendEntries RPC和Candidate角色的Server发出的RequestVote RPC的请求时，应该如何处理，假设先是收到Candidate的请求，在未返回的时候又收到了Leader的请求，或者说先收到Leader的请求，然后收到Candidate的请求时，Follower角色的Server如何处理这三种请求。把上面三个问题想清楚了，那么选举基本问题就能够得到解决

* 如果集群中出现多个Candidate同时发送RequestVote RPC，那么在这一轮（term）无法确认一个Leader，此时Candidate是直接升级自己的term，还是怎么处理。
* 这里有一个问题就是当一个集群正常运行时，如果此时有机器加入了集群，那么这个机器应该和谁通信，和谁通信又是谁确定的，如果确保一台新加入的机器能够和集群中的Leader通信然后成为集群中的一员。
## 二、复制问题

其次列举复制相关问题：
* 复制一问：当Raft集群是不是只能有一个Leader，因为Leader其实是负责面向Client的写操作（目前尚不清楚一个Leader是否负责应对Client的读操作）。我理解一个好的算法，是能够处理大流量的，如果只是单机Leader负责写，那么是无法处理当今互联网业务的。

* 复制二问：如果Raft集群能够存在多个Leader负责Client的写，那么多个Leader之间是如何通信的呢？多个Leader之间是如何解决上面提到的拜占庭将军问题，同时Leader之间是否也需要进行数据同步，因为Raft集群总的Server的同步就需要包含Leader和Follower之间的同步，同时Leader和Follower之间的同步。

* 复制三问：如果Raft集群中的Leader负责应对Client的写，而Follower负责Client的读，那么假设现在Leader将写的数据同步给了Follower，现在来了另一个Client要读这一份数据，那么一部分Follower已经写入，而另一部分Follower还没有写成功，两个用户同时访问，恰好访问到了两个不同Follower上，那么两个 Client看到的结果是不一样的，Raft是如何解决这个问题的呢？

* 复制四问：如果在Leader在负责写数据的时候，同时将数据写入到一部分Follower，而另外一部分Follower没有同步这部分数据，此时Leader宕机了，然后进行选举之后，应该选谁做Leader，同时针对Leader如何保证集群中的Leader的数据和Follower的数据是最终一致的呢？

* 复制五问：这里提到了复制也是一个请求，那么复制这个请求和心跳检测这个请求是否需要公用还是怎样？之前从Kafka的配置中起时心跳检测和数据传输的配置是分开的，那么这些请求是如何实现的呢？


## 三、安全问题



## 笔记

### 关于复制问题：

* 每个Server都会存储一个log文件，同时State Machine主要负责执行log中的执行命令。如果每个Server都有一个log，那么每一次Leader在同步log的时候是增量同步还是全量同步呢？如果是全量同步的网络延时会不会太大呢？如果是增量同步，那么怎么保证Follower已经执行完成了Leader同步的log呢？

### 关于选举问题：

#### 四、选举问题四


## 学习资料
[How I am learning distributed systems](https://medium.com/@polyglot_factotum/how-i-am-learning-distributed-systems-7eb69b4b51bd)