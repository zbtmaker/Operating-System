# 线程池源码解读
线程池顾名思义就是存储线程的地方，因为每次任务来临的时候创建线程，然后处理业务，等业务处理完成之后，线程也随之销毁。如果不断的有业务需要处理，那么需要每次创建线程，处理业务，销毁线程，这个开销很大。因此采用线程池将已创建的线程保存在线程池中，每次有业务需要线程时，可以从线程池获取线程，然后处理业务，业务处理结束之后，将线程交还给线程池管理。

## 线程池相关参数

## 线程池

如果队列中有任务的时候，线程池时时如何运行的，如果线程池中的队列为空的时候，线程池又是如何运行的。

我们首先来看一下当我们提交一个线程时
```java
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```

从上面我们看一下流程
* 使用workerCountOf(c)来计算正在运行的线程数，如果正在运行的线程数小于核心线程数，那么就创建一个Worker来运行提交的任务。
* 使用isRunning(c)来判断线程池是否还在运行，如果线程池停止了运行，此时也不会将任务添加到WorkerQueue中。也就是说如果我们正在运行的线程数>=corePoolSize，此时会将任务添加到WorkerQueue中让任务进入等待状态。
* 添加到队列之后再一次判断线程池是否是运行状态，如果不是运行状态则将刚才添加到WorkerQueue中的任务剔除掉，然后执行对应的拒绝策略。如果线程仍然是运行状态，且线程中没有线程在运行，则创建一个新的Worker来运行提交的任务。
* 如果上述操作都没有成功，则尝试往线程池中创建一个新的Worker，然后运行任务，如果添加Worker失败，则执行拒绝策略。

因此可以从上面描述可以看出，首先会看线程池中正在运行的线程数是否小于核心线程数(corePoolSize)，如果小于核心线程数，则直接创建Worker运行任务，如果超出了核心线程数，则首先把任务添加到WorkerQueue中，如果添加失败，则执行拒绝策略。
我们可以接下来看一下addWorker方法
```java
    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                // 如果正在运行的线程数超出了CAPACITY或者是在corePoolSize已满，或者是队列已满，此时线程池中的线程数超出了maximumPoolSize数量。
                int wc = workerCountOf(c);
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                // 先增加线程池运行线程数，跳出循环
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
        // 这里将创建一个新的Worker来执行任务，然后将任务添加到HashSet中，添加完成之后，就可以开始执行提交的任务了
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            // 创建一个新的Worker来运行任务
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    // 这里使用Thread.start()开启Worker运行
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```
之前看Worker代码的时候怎么也想不明白里面的Worker是如何一直从WorkerQueue中获取Task然后一直执行的，其实Worker本身就是一个Runnable，对于一个Runnable如果想要被执行，那么肯定是要要将Runnable递交给Thread，然后调用Thread的start方法，start方法执行之后会等待操作系统的调用，等到这个线程获取到时间调度片之后就会执行Runnable的run方法。我们可以从上面的方法可以看到当一个当Worker创建好了之后会调用Thread.start()，这个方法之然就会执行Worker的Runnable方法。我们可以看看Worker内部结构。
我们来看一下Worker的方法
```java
    private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
        /**
         * This class will never be serialized, but we provide a
         * serialVersionUID to suppress a javac warning.
         */
        private static final long serialVersionUID = 6138294804551838833L;

        /** Thread this worker is running in.  Null if factory fails. */
        final Thread thread;
        /** Initial task to run.  Possibly null. */
        Runnable firstTask;
        /** Per-thread task counter */
        volatile long completedTasks;

        /**
         * Creates with given first task and thread from ThreadFactory.
         * @param firstTask the first task (null if none)
         */
        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

        /** Delegates main run loop to outer runWorker  */
        public void run() {
            runWorker(this);
        }

        // Lock methods
        //
        // The value 0 represents the unlocked state.
        // The value 1 represents the locked state.

        protected boolean isHeldExclusively() {
            return getState() != 0;
        }

        protected boolean tryAcquire(int unused) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        protected boolean tryRelease(int unused) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        public void lock()        { acquire(1); }
        public boolean tryLock()  { return tryAcquire(1); }
        public void unlock()      { release(1); }
        public boolean isLocked() { return isHeldExclusively(); }

        void interruptIfStarted() {
            Thread t;
            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                }
            }
        }
    }
```

当Worker的Thread运行之后会调用run方法，在run方法内部会调用ThreadPoolExecutor的runWorker方法，此时这个Worker就会不断的从WorkerQueue中获取对应的 task然后交给Worker的Thread中执行。
```java
    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```
## 线程池组件